"use strict";
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNatsComponent = exports.decodeJson = exports.encodeJson = exports.createLocalNatsComponent = void 0;
const nats_1 = require("nats");
const mitt_1 = __importDefault(require("mitt"));
var test_component_1 = require("./test-component");
Object.defineProperty(exports, "createLocalNatsComponent", { enumerable: true, get: function () { return test_component_1.createLocalNatsComponent; } });
var codecs_1 = require("./codecs");
Object.defineProperty(exports, "encodeJson", { enumerable: true, get: function () { return codecs_1.encodeJson; } });
Object.defineProperty(exports, "decodeJson", { enumerable: true, get: function () { return codecs_1.decodeJson; } });
/**
 * Create a NATS component (https://nats.io/)
 * Connect to a NATS node on start(), via the env variable "NATS_URL"
 * @public
 */
async function createNatsComponent(components) {
    const { config, logs } = components;
    // config
    const natsUrl = await config.requireString("NATS_URL");
    const logger = logs.getLogger(`NATS(${natsUrl})`);
    let natsConnection;
    const events = (0, mitt_1.default)();
    function publish(topic, message) {
        if (!natsConnection) {
            throw new Error("NATS component was not started yet");
        }
        natsConnection.publish(topic, message);
    }
    function subscribe(topic, cb) {
        if (!natsConnection) {
            throw new Error("NATS component was not started yet");
        }
        const sub = natsConnection.subscribe(topic, {
            callback: (err, msg) => {
                cb(err, msg);
            },
        });
        sub.closed
            .then(() => {
            logger.debug(`Subscription closed for topic`, { topic });
        })
            .catch((err) => {
            logger.error(`Subscription closed with an error`, err);
        });
        return sub;
    }
    let didStop = false;
    async function printStatus(connection) {
        var e_1, _a;
        try {
            for (var _b = __asyncValues(connection.status()), _c; _c = await _b.next(), !_c.done;) {
                const s = _c.value;
                logger.info(`Status change`, s);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    async function start() {
        try {
            natsConnection = await (0, nats_1.connect)({ servers: `${natsUrl}` });
            printStatus(natsConnection).catch(logger.error);
            natsConnection.closed().then((err) => {
                if (!didStop) {
                    logger.error(`NATS connection lost`);
                    if (err) {
                        logger.error(err);
                    }
                    // TODO: gracefully quit, this is an unrecoverable state
                    process.exit(1);
                }
            });
            events.emit("connected");
            logger.info(`Connected`, { server: natsConnection.getServer() });
        }
        catch (error) {
            logger.error(`An error occurred trying to connect to the NATS server: ${natsUrl}`);
            throw error;
        }
    }
    async function stop() {
        try {
            if (natsConnection) {
                didStop = true;
                await natsConnection.close();
            }
        }
        catch (error) {
            logger.error(error);
        }
    }
    return {
        publish,
        subscribe,
        start,
        stop,
        events,
    };
}
exports.createNatsComponent = createNatsComponent;
//# sourceMappingURL=index.js.map