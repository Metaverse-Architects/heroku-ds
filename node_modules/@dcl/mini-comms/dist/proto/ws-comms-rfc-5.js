"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WsPacket = exports.WsKicked = exports.WsIdentification = exports.WsSignedChallenge = exports.WsChallengeRequired = exports.WsPeerUpdate = exports.WsPeerLeave = exports.WsPeerJoin = exports.WsWelcome_PeerIdentitiesEntry = exports.WsWelcome = exports.protobufPackage = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "protocol.comms.rfc5";
function createBaseWsWelcome() {
    return { alias: 0, peerIdentities: {} };
}
exports.WsWelcome = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.alias !== 0) {
            writer.uint32(8).uint32(message.alias);
        }
        Object.entries(message.peerIdentities).forEach(([key, value]) => {
            exports.WsWelcome_PeerIdentitiesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWsWelcome();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.alias = reader.uint32();
                    break;
                case 2:
                    const entry2 = exports.WsWelcome_PeerIdentitiesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.peerIdentities[entry2.key] = entry2.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            alias: isSet(object.alias) ? Number(object.alias) : 0,
            peerIdentities: isObject(object.peerIdentities)
                ? Object.entries(object.peerIdentities).reduce((acc, [key, value]) => {
                    acc[Number(key)] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        message.alias !== undefined && (obj.alias = Math.round(message.alias));
        obj.peerIdentities = {};
        if (message.peerIdentities) {
            Object.entries(message.peerIdentities).forEach(([k, v]) => {
                obj.peerIdentities[k] = v;
            });
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWsWelcome();
        message.alias = object.alias ?? 0;
        message.peerIdentities = Object.entries(object.peerIdentities ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[Number(key)] = String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseWsWelcome_PeerIdentitiesEntry() {
    return { key: 0, value: "" };
}
exports.WsWelcome_PeerIdentitiesEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== 0) {
            writer.uint32(8).uint32(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWsWelcome_PeerIdentitiesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.uint32();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { key: isSet(object.key) ? Number(object.key) : 0, value: isSet(object.value) ? String(object.value) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = Math.round(message.key));
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWsWelcome_PeerIdentitiesEntry();
        message.key = object.key ?? 0;
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseWsPeerJoin() {
    return { alias: 0, address: "" };
}
exports.WsPeerJoin = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.alias !== 0) {
            writer.uint32(8).uint32(message.alias);
        }
        if (message.address !== "") {
            writer.uint32(18).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWsPeerJoin();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.alias = reader.uint32();
                    break;
                case 2:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            alias: isSet(object.alias) ? Number(object.alias) : 0,
            address: isSet(object.address) ? String(object.address) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.alias !== undefined && (obj.alias = Math.round(message.alias));
        message.address !== undefined && (obj.address = message.address);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWsPeerJoin();
        message.alias = object.alias ?? 0;
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseWsPeerLeave() {
    return { alias: 0 };
}
exports.WsPeerLeave = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.alias !== 0) {
            writer.uint32(8).uint32(message.alias);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWsPeerLeave();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.alias = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { alias: isSet(object.alias) ? Number(object.alias) : 0 };
    },
    toJSON(message) {
        const obj = {};
        message.alias !== undefined && (obj.alias = Math.round(message.alias));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWsPeerLeave();
        message.alias = object.alias ?? 0;
        return message;
    },
};
function createBaseWsPeerUpdate() {
    return { fromAlias: 0, body: new Uint8Array(), unreliable: false };
}
exports.WsPeerUpdate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.fromAlias !== 0) {
            writer.uint32(8).uint32(message.fromAlias);
        }
        if (message.body.length !== 0) {
            writer.uint32(18).bytes(message.body);
        }
        if (message.unreliable === true) {
            writer.uint32(24).bool(message.unreliable);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWsPeerUpdate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.fromAlias = reader.uint32();
                    break;
                case 2:
                    message.body = reader.bytes();
                    break;
                case 3:
                    message.unreliable = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            fromAlias: isSet(object.fromAlias) ? Number(object.fromAlias) : 0,
            body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(),
            unreliable: isSet(object.unreliable) ? Boolean(object.unreliable) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.fromAlias !== undefined && (obj.fromAlias = Math.round(message.fromAlias));
        message.body !== undefined &&
            (obj.body = base64FromBytes(message.body !== undefined ? message.body : new Uint8Array()));
        message.unreliable !== undefined && (obj.unreliable = message.unreliable);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWsPeerUpdate();
        message.fromAlias = object.fromAlias ?? 0;
        message.body = object.body ?? new Uint8Array();
        message.unreliable = object.unreliable ?? false;
        return message;
    },
};
function createBaseWsChallengeRequired() {
    return { challengeToSign: "", alreadyConnected: false };
}
exports.WsChallengeRequired = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.challengeToSign !== "") {
            writer.uint32(10).string(message.challengeToSign);
        }
        if (message.alreadyConnected === true) {
            writer.uint32(16).bool(message.alreadyConnected);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWsChallengeRequired();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.challengeToSign = reader.string();
                    break;
                case 2:
                    message.alreadyConnected = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            challengeToSign: isSet(object.challengeToSign) ? String(object.challengeToSign) : "",
            alreadyConnected: isSet(object.alreadyConnected) ? Boolean(object.alreadyConnected) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.challengeToSign !== undefined && (obj.challengeToSign = message.challengeToSign);
        message.alreadyConnected !== undefined && (obj.alreadyConnected = message.alreadyConnected);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWsChallengeRequired();
        message.challengeToSign = object.challengeToSign ?? "";
        message.alreadyConnected = object.alreadyConnected ?? false;
        return message;
    },
};
function createBaseWsSignedChallenge() {
    return { authChainJson: "" };
}
exports.WsSignedChallenge = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.authChainJson !== "") {
            writer.uint32(10).string(message.authChainJson);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWsSignedChallenge();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.authChainJson = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { authChainJson: isSet(object.authChainJson) ? String(object.authChainJson) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.authChainJson !== undefined && (obj.authChainJson = message.authChainJson);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWsSignedChallenge();
        message.authChainJson = object.authChainJson ?? "";
        return message;
    },
};
function createBaseWsIdentification() {
    return { address: "" };
}
exports.WsIdentification = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWsIdentification();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { address: isSet(object.address) ? String(object.address) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWsIdentification();
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseWsKicked() {
    return {};
}
exports.WsKicked = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWsKicked();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseWsKicked();
        return message;
    },
};
function createBaseWsPacket() {
    return {
        welcomeMessage: undefined,
        peerJoinMessage: undefined,
        peerUpdateMessage: undefined,
        challengeMessage: undefined,
        signedChallengeForServer: undefined,
        peerLeaveMessage: undefined,
        peerIdentification: undefined,
        peerKicked: undefined,
    };
}
exports.WsPacket = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.welcomeMessage !== undefined) {
            exports.WsWelcome.encode(message.welcomeMessage, writer.uint32(10).fork()).ldelim();
        }
        if (message.peerJoinMessage !== undefined) {
            exports.WsPeerJoin.encode(message.peerJoinMessage, writer.uint32(18).fork()).ldelim();
        }
        if (message.peerUpdateMessage !== undefined) {
            exports.WsPeerUpdate.encode(message.peerUpdateMessage, writer.uint32(26).fork()).ldelim();
        }
        if (message.challengeMessage !== undefined) {
            exports.WsChallengeRequired.encode(message.challengeMessage, writer.uint32(34).fork()).ldelim();
        }
        if (message.signedChallengeForServer !== undefined) {
            exports.WsSignedChallenge.encode(message.signedChallengeForServer, writer.uint32(42).fork()).ldelim();
        }
        if (message.peerLeaveMessage !== undefined) {
            exports.WsPeerLeave.encode(message.peerLeaveMessage, writer.uint32(50).fork()).ldelim();
        }
        if (message.peerIdentification !== undefined) {
            exports.WsIdentification.encode(message.peerIdentification, writer.uint32(58).fork()).ldelim();
        }
        if (message.peerKicked !== undefined) {
            exports.WsKicked.encode(message.peerKicked, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWsPacket();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.welcomeMessage = exports.WsWelcome.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.peerJoinMessage = exports.WsPeerJoin.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.peerUpdateMessage = exports.WsPeerUpdate.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.challengeMessage = exports.WsChallengeRequired.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.signedChallengeForServer = exports.WsSignedChallenge.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.peerLeaveMessage = exports.WsPeerLeave.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.peerIdentification = exports.WsIdentification.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.peerKicked = exports.WsKicked.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            welcomeMessage: isSet(object.welcomeMessage) ? exports.WsWelcome.fromJSON(object.welcomeMessage) : undefined,
            peerJoinMessage: isSet(object.peerJoinMessage) ? exports.WsPeerJoin.fromJSON(object.peerJoinMessage) : undefined,
            peerUpdateMessage: isSet(object.peerUpdateMessage) ? exports.WsPeerUpdate.fromJSON(object.peerUpdateMessage) : undefined,
            challengeMessage: isSet(object.challengeMessage)
                ? exports.WsChallengeRequired.fromJSON(object.challengeMessage)
                : undefined,
            signedChallengeForServer: isSet(object.signedChallengeForServer)
                ? exports.WsSignedChallenge.fromJSON(object.signedChallengeForServer)
                : undefined,
            peerLeaveMessage: isSet(object.peerLeaveMessage) ? exports.WsPeerLeave.fromJSON(object.peerLeaveMessage) : undefined,
            peerIdentification: isSet(object.peerIdentification)
                ? exports.WsIdentification.fromJSON(object.peerIdentification)
                : undefined,
            peerKicked: isSet(object.peerKicked) ? exports.WsKicked.fromJSON(object.peerKicked) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.welcomeMessage !== undefined &&
            (obj.welcomeMessage = message.welcomeMessage ? exports.WsWelcome.toJSON(message.welcomeMessage) : undefined);
        message.peerJoinMessage !== undefined &&
            (obj.peerJoinMessage = message.peerJoinMessage ? exports.WsPeerJoin.toJSON(message.peerJoinMessage) : undefined);
        message.peerUpdateMessage !== undefined &&
            (obj.peerUpdateMessage = message.peerUpdateMessage ? exports.WsPeerUpdate.toJSON(message.peerUpdateMessage) : undefined);
        message.challengeMessage !== undefined && (obj.challengeMessage = message.challengeMessage
            ? exports.WsChallengeRequired.toJSON(message.challengeMessage)
            : undefined);
        message.signedChallengeForServer !== undefined && (obj.signedChallengeForServer = message.signedChallengeForServer
            ? exports.WsSignedChallenge.toJSON(message.signedChallengeForServer)
            : undefined);
        message.peerLeaveMessage !== undefined &&
            (obj.peerLeaveMessage = message.peerLeaveMessage ? exports.WsPeerLeave.toJSON(message.peerLeaveMessage) : undefined);
        message.peerIdentification !== undefined && (obj.peerIdentification = message.peerIdentification
            ? exports.WsIdentification.toJSON(message.peerIdentification)
            : undefined);
        message.peerKicked !== undefined &&
            (obj.peerKicked = message.peerKicked ? exports.WsKicked.toJSON(message.peerKicked) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWsPacket();
        message.welcomeMessage = (object.welcomeMessage !== undefined && object.welcomeMessage !== null)
            ? exports.WsWelcome.fromPartial(object.welcomeMessage)
            : undefined;
        message.peerJoinMessage = (object.peerJoinMessage !== undefined && object.peerJoinMessage !== null)
            ? exports.WsPeerJoin.fromPartial(object.peerJoinMessage)
            : undefined;
        message.peerUpdateMessage = (object.peerUpdateMessage !== undefined && object.peerUpdateMessage !== null)
            ? exports.WsPeerUpdate.fromPartial(object.peerUpdateMessage)
            : undefined;
        message.challengeMessage = (object.challengeMessage !== undefined && object.challengeMessage !== null)
            ? exports.WsChallengeRequired.fromPartial(object.challengeMessage)
            : undefined;
        message.signedChallengeForServer =
            (object.signedChallengeForServer !== undefined && object.signedChallengeForServer !== null)
                ? exports.WsSignedChallenge.fromPartial(object.signedChallengeForServer)
                : undefined;
        message.peerLeaveMessage = (object.peerLeaveMessage !== undefined && object.peerLeaveMessage !== null)
            ? exports.WsPeerLeave.fromPartial(object.peerLeaveMessage)
            : undefined;
        message.peerIdentification = (object.peerIdentification !== undefined && object.peerIdentification !== null)
            ? exports.WsIdentification.fromPartial(object.peerIdentification)
            : undefined;
        message.peerKicked = (object.peerKicked !== undefined && object.peerKicked !== null)
            ? exports.WsKicked.fromPartial(object.peerKicked)
            : undefined;
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=ws-comms-rfc-5.js.map