"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pushableChannel = void 0;
function pushableChannel(onIteratorClose) {
    let returnLock = null;
    const queue = [];
    let closed = false;
    let error = null;
    let lastResolver = null;
    function releaseLockIfNeeded() {
        // signal that we have a value
        if (returnLock) {
            const originalReturnLock = returnLock;
            returnLock = null;
            originalReturnLock();
        }
    }
    async function push(value) {
        if (closed)
            throw new Error("Channel is closed");
        if (error) {
            throw error;
        }
        // push the value to the queue
        return new Promise((resolve) => {
            queue.push({ value, resolve });
            releaseLockIfNeeded();
        });
    }
    // resolves the promise returned by push(T)
    function markConsumed() {
        if (lastResolver) {
            lastResolver();
            lastResolver = null;
        }
    }
    function failAndClose(errorToThrow) {
        error = errorToThrow;
        close();
    }
    function yieldNextResult() {
        if (error && queue.length == 0) {
            throw error;
        }
        if (closed && queue.length == 0) {
            return { done: true, value: undefined };
        }
        if (queue.length) {
            if (lastResolver) {
                throw new Error("logic error, this should never happen");
            }
            const { value, resolve } = queue.shift();
            lastResolver = resolve;
            return {
                done: false,
                value,
            };
        }
    }
    function close() {
        if (!closed) {
            markConsumed();
            closed = true;
            releaseLockIfNeeded();
            onIteratorClose();
        }
    }
    const iterable = {
        async next() {
            while (true) {
                try {
                    markConsumed();
                    const result = yieldNextResult();
                    if (result) {
                        return result;
                    }
                    else {
                        await new Promise((res) => (returnLock = res));
                    }
                }
                catch (err) {
                    error = err;
                    close();
                    throw err;
                }
            }
        },
        async return(value) {
            close();
            return { done: true, value: undefined };
        },
        async throw(e) {
            if (error) {
                throw error;
            }
            close();
            return { done: true, value: undefined };
        },
        [Symbol.asyncIterator]() {
            return iterable;
        },
    };
    function isClosed() {
        return closed;
    }
    return { iterable, push, close, failAndClose, isClosed, [Symbol.asyncIterator]: () => iterable };
}
exports.pushableChannel = pushableChannel;
//# sourceMappingURL=push-channel.js.map