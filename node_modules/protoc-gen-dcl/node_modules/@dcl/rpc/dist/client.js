"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRpcClient = exports.streamFromDispatcher = exports.createPort = void 0;
const mitt_1 = __importDefault(require("mitt"));
const index_pb_1 = require("./protocol/index_pb");
const message_number_handler_1 = require("./message-number-handler");
const push_channel_1 = require("./push-channel");
const helpers_1 = require("./protocol/helpers");
const EMPTY_U8 = new Uint8Array(0);
// @internal
function createPort(portId, portName, dispatcher) {
    const events = (0, mitt_1.default)();
    let state = "open";
    events.on("close", () => (state = "closed"));
    return {
        ...events,
        portName,
        portId,
        get state() {
            return state;
        },
        close() {
            const m = new index_pb_1.DestroyPort();
            m.setPortId(portId);
            m.setMessageType(index_pb_1.RpcMessageTypes.RPCMESSAGETYPES_DESTROY_PORT);
            dispatcher.transport.sendMessage(m.serializeBinary());
            events.emit("close", {});
        },
        async loadModule(moduleName) {
            const requestModuleMessage = new index_pb_1.RequestModule();
            requestModuleMessage.setModuleName(moduleName);
            requestModuleMessage.setPortId(portId);
            requestModuleMessage.setMessageType(index_pb_1.RpcMessageTypes.RPCMESSAGETYPES_REQUEST_MODULE);
            const ret = await dispatcher.request(requestModuleMessage);
            const parsedMessage = (0, helpers_1.parseProtocolMessage)(ret);
            if (parsedMessage instanceof index_pb_1.RequestModuleResponse) {
                const ret = {};
                for (let procedure of parsedMessage.getProceduresList()) {
                    ret[procedure.getProcedureName()] = createProcedure(portId, procedure.getProcedureId(), dispatcher);
                }
                return ret;
            }
            else if (parsedMessage instanceof index_pb_1.RemoteError) {
                throwIfRemoteError(parsedMessage);
            }
            throw new Error("Unknown response received from server.");
        },
    };
}
exports.createPort = createPort;
function throwIfRemoteError(parsedMessage) {
    if (parsedMessage instanceof index_pb_1.RemoteError) {
        throw new Error("RemoteError: " + parsedMessage.getErrorMessage());
    }
}
// @internal
function streamFromDispatcher(dispatcher, streamMessage) {
    const { iterable, push, close, failAndClose, isClosed } = (0, push_channel_1.pushableChannel)(localIteratorClosed);
    let lastReceivedSequenceId = 0;
    let isRemoteClosed = false;
    dispatcher.transport.on("close", () => {
        if (!isClosed()) {
            failAndClose(new Error("RPC Transport closed"));
        }
    });
    dispatcher.transport.on("error", () => {
        if (!isClosed()) {
            failAndClose(new Error("RPC Transport failed"));
        }
    });
    function localIteratorClosed() {
        if (!isRemoteClosed) {
            dispatcher.transport.sendMessage((0, helpers_1.closeStreamMessage)(streamMessage.getMessageId(), lastReceivedSequenceId, streamMessage.getPortId()));
        }
        dispatcher.removeListener(streamMessage.getMessageId());
    }
    function processMessage(message) {
        lastReceivedSequenceId = message.getSequenceId();
        if (message.getClosed()) {
            isRemoteClosed = true;
            close();
        }
        else {
            const payload = message.getPayload_asU8();
            push(payload)
                .then(() => {
                const closed = isClosed();
                if (!closed && !isRemoteClosed) {
                    dispatcher.transport.sendMessage((0, helpers_1.streamAckMessage)(message.getMessageId(), lastReceivedSequenceId, message.getPortId()));
                }
            })
                .catch(failAndClose);
        }
    }
    dispatcher.addListener(streamMessage.getMessageId(), (reader) => {
        const message = (0, helpers_1.parseProtocolMessage)(reader);
        if (message instanceof index_pb_1.StreamMessage) {
            processMessage(message);
        }
        else if (message instanceof index_pb_1.RemoteError) {
            isRemoteClosed = true;
            failAndClose(new Error("RemoteError: " + (message.getErrorMessage() || "Unknown remote error")));
        }
        else {
            failAndClose(new Error("RemoteError: Protocol error"));
        }
    });
    processMessage(streamMessage);
    return iterable;
}
exports.streamFromDispatcher = streamFromDispatcher;
// @internal
function createProcedure(portId, procedureId, dispatcher) {
    const callProcedurePacket = new index_pb_1.Request();
    callProcedurePacket.setPortId(portId);
    callProcedurePacket.setProcedureId(procedureId);
    callProcedurePacket.setMessageType(index_pb_1.RpcMessageTypes.RPCMESSAGETYPES_REQUEST);
    return async function (data) {
        if (data) {
            callProcedurePacket.setPayload(data);
        }
        else {
            callProcedurePacket.setPayload(EMPTY_U8);
        }
        const ret = (0, helpers_1.parseProtocolMessage)(await dispatcher.request(callProcedurePacket));
        if (ret instanceof index_pb_1.Response) {
            const u8 = ret.getPayload_asU8();
            if (u8.length) {
                return u8;
            }
            else {
                return undefined;
            }
        }
        else if (ret instanceof index_pb_1.StreamMessage) {
            return streamFromDispatcher(dispatcher, ret);
        }
        else {
            throwIfRemoteError(ret);
            debugger;
        }
    };
}
/**
 * @public
 */
async function createRpcClient(transport) {
    const clientPortByName = new Map();
    const dispatcher = (0, message_number_handler_1.messageNumberHandler)(transport);
    async function internalCreatePort(portName) {
        const createPortMessage = new index_pb_1.CreatePort();
        createPortMessage.setMessageType(index_pb_1.RpcMessageTypes.RPCMESSAGETYPES_CREATE_PORT);
        createPortMessage.setPortName(portName);
        const ret = await dispatcher.request(createPortMessage);
        const parsedMessage = (0, helpers_1.parseProtocolMessage)(ret);
        throwIfRemoteError(parsedMessage);
        if (parsedMessage instanceof index_pb_1.CreatePortResponse) {
            const portId = parsedMessage.getPortId();
            return createPort(portId, portName, dispatcher);
        }
        throw new Error("Unknown response received from server.");
    }
    // wait for transport to be connected
    await new Promise((resolve, reject) => {
        transport.on("connect", resolve);
        transport.on("error", reject);
    });
    return {
        // the only objective of this function is to deduplicate asynchronous calls
        // and produce an idempotent module load
        async createPort(portName) {
            if (clientPortByName.has(portName)) {
                return clientPortByName.get(portName);
            }
            const portFuture = internalCreatePort(portName);
            clientPortByName.set(portName, portFuture);
            const port = await portFuture;
            port.on("close", () => {
                if (clientPortByName.get(portName) === portFuture) {
                    clientPortByName.delete(portName);
                }
            });
            return port;
        },
    };
}
exports.createRpcClient = createRpcClient;
//# sourceMappingURL=client.js.map