"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRpcServer = exports.handleRequest = exports.handleDestroyPort = exports.handleRequestModule = exports.handleCreatePort = exports.createServerPort = void 0;
const mitt_1 = __importDefault(require("mitt"));
const index_pb_1 = require("./protocol/index_pb");
const google_protobuf_1 = require("google-protobuf");
const ack_helper_1 = require("./ack-helper");
const helpers_1 = require("./protocol/helpers");
let lastPortId = 0;
function getServerReadyMessage() {
    const transportStartMessage = new index_pb_1.RpcMessageHeader();
    transportStartMessage.setMessageType(index_pb_1.RpcMessageTypes.RPCMESSAGETYPES_SERVER_READY);
    return transportStartMessage.serializeBinary();
}
const transportStartMessageSerialized = getServerReadyMessage();
const reusedCreatePortResponse = new index_pb_1.CreatePortResponse();
reusedCreatePortResponse.setMessageType(index_pb_1.RpcMessageTypes.RPCMESSAGETYPES_CREATE_PORT_RESPONSE);
const reusedRequestModuleResponse = new index_pb_1.RequestModuleResponse();
reusedRequestModuleResponse.setMessageType(index_pb_1.RpcMessageTypes.RPCMESSAGETYPES_REQUEST_MODULE_RESPONSE);
const reusedResponse = new index_pb_1.Response();
reusedResponse.setMessageType(index_pb_1.RpcMessageTypes.RPCMESSAGETYPES_RESPONSE);
const reusedRemoteError = new index_pb_1.RemoteError();
reusedRemoteError.setMessageType(index_pb_1.RpcMessageTypes.RPCMESSAGETYPES_REMOTE_ERROR_RESPONSE);
function moduleProcedures(module) {
    return Array.from(Object.entries(module)).filter(([name, value]) => typeof value == "function");
}
/**
 * @internal
 */
function createServerPort(portId, portName) {
    const events = (0, mitt_1.default)();
    const loadedModules = new Map();
    const procedures = new Map();
    const registeredModules = new Map();
    const port = {
        get portId() {
            return portId;
        },
        get portName() {
            return portName;
        },
        ...events,
        registerModule,
        loadModule,
        close,
        callProcedure,
    };
    async function close() {
        loadedModules.clear();
        procedures.clear();
        registeredModules.clear();
        events.emit("close", {});
    }
    async function registerModule(moduleName, generator) {
        if (registeredModules.has(moduleName)) {
            throw new Error(`module ${moduleName} is already registered for port ${portName} (${portId}))`);
        }
        registeredModules.set(moduleName, generator);
    }
    async function loadModuleFromGenerator(moduleFuture) {
        const module = await moduleFuture;
        const ret = {
            procedures: [],
        };
        for (const [procedureName, callable] of moduleProcedures(module)) {
            const procedureId = procedures.size + 1;
            procedures.set(procedureId, callable);
            ret.procedures.push({
                procedureName,
                callable,
                procedureId,
            });
        }
        return ret;
    }
    function loadModule(moduleName) {
        if (loadedModules.has(moduleName)) {
            return loadedModules.get(moduleName);
        }
        const moduleGenerator = registeredModules.get(moduleName);
        if (!moduleGenerator) {
            throw new Error(`Module ${moduleName} is not available for port ${portName} (${portId}))`);
        }
        const moduleFuture = loadModuleFromGenerator(moduleGenerator(port));
        loadedModules.set(moduleName, moduleFuture);
        return moduleFuture;
    }
    function callProcedure(procedureId, payload) {
        const procedure = procedures.get(procedureId);
        if (!procedure) {
            throw new Error(`procedureId ${procedureId} is missing in ${portName} (${portId}))`);
        }
        return procedure(payload);
    }
    return port;
}
exports.createServerPort = createServerPort;
function getPortFromState(portId, transport, state) {
    return state.portsByTransport.get(transport)?.get(portId);
}
// @internal
async function handleCreatePort(transport, createPortMessage, options, state) {
    lastPortId++;
    const port = createServerPort(lastPortId, createPortMessage.getPortName());
    const byTransport = state.portsByTransport.get(transport) || new Map();
    byTransport.set(port.portId, port);
    state.ports.set(port.portId, port);
    state.portsByTransport.set(transport, byTransport);
    await options.initializePort(port, transport);
    reusedCreatePortResponse.setMessageId(createPortMessage.getMessageId());
    reusedCreatePortResponse.setPortId(port.portId);
    transport.sendMessage(reusedCreatePortResponse.serializeBinary());
    return port;
}
exports.handleCreatePort = handleCreatePort;
// @internal
async function handleRequestModule(transport, requestModule, state) {
    const port = getPortFromState(requestModule.getPortId(), transport, state);
    if (!port) {
        throw new Error(`Cannot find port ${requestModule.getPortId()}`);
    }
    const loadedModule = await port.loadModule(requestModule.getModuleName());
    reusedRequestModuleResponse.setMessageId(requestModule.getMessageId());
    reusedRequestModuleResponse.setPortId(port.portId);
    reusedRequestModuleResponse.setProceduresList([]);
    for (const procedure of loadedModule.procedures) {
        const n = new index_pb_1.ModuleProcedure();
        n.setProcedureId(procedure.procedureId);
        n.setProcedureName(procedure.procedureName);
        reusedRequestModuleResponse.addProcedures(n);
    }
    transport.sendMessage(reusedRequestModuleResponse.serializeBinary());
}
exports.handleRequestModule = handleRequestModule;
// @internal
async function handleDestroyPort(transport, request, state) {
    const port = getPortFromState(request.getPortId(), transport, state);
    if (port) {
        port.emit("close", {});
    }
}
exports.handleDestroyPort = handleDestroyPort;
// @internal
async function handleRequest(ackDispatcher, request, state) {
    const port = getPortFromState(request.getPortId(), ackDispatcher.transport, state);
    if (!port) {
        reusedRemoteError.setMessageId(request.getMessageId());
        reusedRemoteError.setErrorMessage("invalid portId");
        ackDispatcher.transport.sendMessage(reusedRemoteError.serializeBinary());
        return;
    }
    const result = await port.callProcedure(request.getProcedureId(), request.getPayload_asU8());
    reusedResponse.setMessageId(request.getMessageId());
    reusedResponse.setPayload("");
    if (result instanceof Uint8Array) {
        reusedResponse.setPayload(result);
        ackDispatcher.transport.sendMessage(reusedResponse.serializeBinary());
    }
    else if (result && Symbol.asyncIterator in result) {
        const iter = await result[Symbol.asyncIterator]();
        let sequenceNumber = -1;
        const reusedStreamMessage = new index_pb_1.StreamMessage();
        reusedStreamMessage.setMessageType(index_pb_1.RpcMessageTypes.RPCMESSAGETYPES_STREAM_MESSAGE);
        const transportClosedRejection = new Promise((_, reject) => ackDispatcher.transport.on("close", reject));
        for await (const elem of iter) {
            sequenceNumber++;
            reusedStreamMessage.setClosed(false);
            reusedStreamMessage.setAck(false);
            reusedStreamMessage.setSequenceId(sequenceNumber);
            reusedStreamMessage.setMessageId(request.getMessageId());
            reusedStreamMessage.setPayload(elem);
            reusedStreamMessage.setPortId(request.getPortId());
            // we use Promise.race to react to the transport close events
            const ret = await Promise.race([ackDispatcher.sendWithAck(reusedStreamMessage), transportClosedRejection]);
            if (ret.getAck()) {
                continue;
            }
            else if (ret.getClosed()) {
                // if it was closed remotely, then we end the stream right away
                return;
            }
        }
        ackDispatcher.transport.sendMessage((0, helpers_1.closeStreamMessage)(request.getMessageId(), sequenceNumber, request.getPortId()));
    }
    else {
        ackDispatcher.transport.sendMessage(reusedResponse.serializeBinary());
    }
}
exports.handleRequest = handleRequest;
/**
 * @public
 */
function createRpcServer(options) {
    const events = (0, mitt_1.default)();
    const state = {
        ports: new Map(),
        portsByTransport: new Map(),
        transports: new Set(),
    };
    function removeTransport(transport) {
        const transportPorts = state.portsByTransport.get(transport);
        state.portsByTransport.delete(transport);
        if (transportPorts && transportPorts.size) {
            transportPorts.forEach(($) => $.close());
        }
        if (state.transports.delete(transport)) {
            events.emit("transportClosed", { transport });
        }
    }
    events.on("portClosed", (evt) => {
        const { port } = evt;
        state.ports.delete(port.portId);
    });
    function handleTransportError(transport, error) {
        events.emit("transportError", { transport, error });
        transport.close();
        removeTransport(transport);
    }
    function handleWithErrorMessage(promise, parsedMessage, transport) {
        promise.catch((err) => {
            reusedRemoteError.setMessageId(parsedMessage.getMessageId());
            reusedRemoteError.setErrorMessage(err.message);
            transport.sendMessage(reusedRemoteError.serializeBinary());
        });
    }
    async function handleMessage(parsedMessage, transport, ackHelper) {
        if (parsedMessage instanceof index_pb_1.Request) {
            await handleRequest(ackHelper, parsedMessage, state);
        }
        else if (parsedMessage instanceof index_pb_1.RequestModule) {
            await handleRequestModule(transport, parsedMessage, state);
        }
        else if (parsedMessage instanceof index_pb_1.CreatePort) {
            const port = await handleCreatePort(transport, parsedMessage, options, state);
            port.on("close", () => events.emit("portClosed", { port }));
        }
        else if (parsedMessage instanceof index_pb_1.DestroyPort) {
            await handleDestroyPort(transport, parsedMessage, state);
        }
        else if (parsedMessage instanceof index_pb_1.StreamMessage) {
            // noop
        }
        else {
            transport.emit("error", new Error(`Unknown message ${JSON.stringify(parsedMessage?.toObject())}`));
        }
    }
    return {
        ...events,
        attachTransport(newTransport) {
            state.transports.add(newTransport);
            const ackHelper = (0, ack_helper_1.createAckHelper)(newTransport);
            newTransport.on("message", (message) => {
                const reader = new google_protobuf_1.BinaryReader(message);
                const parsedMessage = (0, helpers_1.parseProtocolMessage)(reader);
                if (parsedMessage) {
                    handleWithErrorMessage(handleMessage(parsedMessage, newTransport, ackHelper), parsedMessage, newTransport);
                }
            });
            newTransport.on("close", () => {
                removeTransport(newTransport);
            });
            newTransport.on("error", (error) => {
                handleTransportError(newTransport, error);
            });
            // send the signal to the transport
            newTransport.sendMessage(transportStartMessageSerialized);
        },
    };
}
exports.createRpcServer = createRpcServer;
//# sourceMappingURL=server.js.map