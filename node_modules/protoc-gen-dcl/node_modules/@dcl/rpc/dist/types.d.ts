import { Emitter } from "mitt";
/**
 * @public
 */
export declare type TransportEvents = {
    /**
     * The connect event is emited when the transport gets connected.
     *
     * The RpcServer is in charge to send the notification (bytes[1]\{0x0\})
     * to signal the client transport that it is connected.
     */
    connect: {};
    /** the onMessage callback is called when the transport receives a message */
    message: Uint8Array;
    /** the error event is emited when the transport triggers an error */
    error: Error;
    /** the close function will be called when it is decided to end the communication */
    close: {};
};
/**
 * @public
 */
export declare type Transport = Emitter<TransportEvents> & {
    /** sendMessage is used to send a message through the transport */
    sendMessage(message: Uint8Array): void;
    close(): void;
};
/**
 * @public
 */
export declare type AsyncProcedureResultServer = Promise<Uint8Array | void> | AsyncGenerator<Uint8Array>;
/**
 * @public
 */
export declare type AsyncProcedureResultClient = Promise<Uint8Array | AsyncGenerator<Uint8Array> | void>;
/**
 * @public
 */
export declare type CallableProcedureServer = (payload: Uint8Array) => AsyncProcedureResultServer;
/**
 * @public
 */
export declare type CallableProcedureClient = (payload: Uint8Array) => AsyncProcedureResultClient;
/**
 * @public
 */
export declare type ServerModuleProcedure = {
    procedureName: string;
    procedureId: number;
    callable: CallableProcedureServer;
};
/**
 * @public
 */
export declare type ServerModuleDeclaration = {
    procedures: ServerModuleProcedure[];
};
/**
 * @public
 */
export declare type ServerModuleDefinition = Record<string, CallableProcedureServer>;
/**
 * @public
 */
export declare type ClientModuleDefinition = Record<string, CallableProcedureClient>;
/**
 * @public
 */
export declare type SendableMessage = {
    setMessageId(number: number): void;
    serializeBinary(): Uint8Array;
};
/**
 * @public
 */
export declare type RpcPortEvents = {
    close: {};
};
/**
 * @public
 */
export declare type RpcClientPort = Emitter<RpcPortEvents> & {
    readonly portId: number;
    readonly portName: string;
    loadModule(moduleName: string): Promise<unknown>;
    close(): void;
    readonly state: 'open' | 'closed';
};
/**
 * @public
 */
export declare type RpcClient = {
    createPort(portName: string): Promise<RpcClientPort>;
};
/**
 * @public
 */
export declare type ModuleGeneratorFunction = (port: RpcServerPort) => Promise<ServerModuleDefinition>;
/**
 * @public
 */
export declare type RpcServerPort = Emitter<RpcPortEvents> & {
    readonly portId: number;
    readonly portName: string;
    /**
     * Used to register the available APIs for the specified port
     */
    registerModule(moduleName: string, moduleDefinition: ModuleGeneratorFunction): void;
    /**
     * Used to load modules based on their definition and availability.
     */
    loadModule(moduleName: string): Promise<ServerModuleDeclaration>;
    callProcedure(procedureId: number, argument: Uint8Array): AsyncProcedureResultServer;
    close(): void;
};
/**
 * @public
 */
export declare type RpcServerEvents = {
    portCreated: {
        port: RpcServerPort;
    };
    portClosed: {
        port: RpcServerPort;
    };
    transportClosed: {
        transport: Transport;
    };
    transportError: {
        transport: Transport;
        error: Error;
    };
};
/**
 * Once a transport is created and ready to be used, it must be
 * attached to the server to wire the business logic that creates the
 * modules. Servers are only helper functions that maps ports to
 * their implementation of functions.
 *
 * Once transports are closed, all the ports belonging to the transport
 * are closed.
 *
 * The RpcServer also generates the portIds.
 * @public
 */
export declare type RpcServer = Emitter<RpcServerEvents> & {
    attachTransport(transport: Transport): void;
};
//# sourceMappingURL=types.d.ts.map