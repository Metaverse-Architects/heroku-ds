"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serverProcedureStream = exports.serverProcedureUnary = exports.clientProcedureStream = exports.clientProcedureUnary = void 0;
function clientProcedureUnary(port, name, requestType, requestResponseConstructor) {
    const fn = async (arg) => {
        const remoteModule = (await port);
        if (!(arg instanceof requestType))
            throw new Error("Argument passed to RPC Method " + name + " type mismatch.");
        if (!(name in remoteModule))
            throw new Error("Method " + name + " not implemented in server port");
        const result = await remoteModule[name](arg.serializeBinary());
        if (!result) {
            throw new Error("Server sent an empty or null response to method call " + name);
        }
        return requestResponseConstructor.deserializeBinary(result);
    };
    return fn;
}
exports.clientProcedureUnary = clientProcedureUnary;
function clientProcedureStream(port, name, requestType, requestResponseConstructor) {
    const fn = async function* (arg) {
        const remoteModule = (await port);
        if (!(arg instanceof requestType))
            throw new Error("Argument passed to RPC Method " + name + " type mismatch.");
        if (!(name in remoteModule))
            throw new Error("Method " + name + " not implemented in server port");
        const result = await remoteModule[name](arg.serializeBinary());
        if (!result) {
            throw new Error("Server sent an empty or null response to method call " + name);
        }
        for await (const bytes of await result) {
            yield requestResponseConstructor.deserializeBinary(bytes);
        }
    };
    return fn;
}
exports.clientProcedureStream = clientProcedureStream;
function serverProcedureUnary(fn, name, ctor1, ctor2) {
    return async function (argBinary) {
        const arg = ctor1.deserializeBinary(argBinary);
        const result = await fn(arg);
        if (!result)
            throw new Error("Empty or null responses are not allowed. Procedure: " + name);
        if (!(result instanceof ctor2))
            throw new Error("Result of procedure " + name + " did not match the expected constructor");
        return result.serializeBinary();
    };
}
exports.serverProcedureUnary = serverProcedureUnary;
function serverProcedureStream(fn, name, ctor1, ctor2) {
    return async function* (argBinary) {
        const arg = ctor1.deserializeBinary(argBinary);
        const result = await fn(arg);
        if (!result)
            throw new Error("Empty or null responses are not allowed. Procedure: " + name);
        for await (const elem of result) {
            if (!(elem instanceof ctor2))
                throw new Error("Yielded result of procedure " + name + " did not match the expected constructor");
            yield elem.serializeBinary();
        }
    };
}
exports.serverProcedureStream = serverProcedureStream;
//# sourceMappingURL=codegen.js.map